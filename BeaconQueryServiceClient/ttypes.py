#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class ErrorCode(object):
    ILLEGAL_ARGUMENT = 0
    AUTHENTICATION_FAILED = 1
    DB_FAILED = 2
    INVALID_STATE = 3
    EXCESSIVE_ACCESS = 4
    NOT_FOUND = 5
    INVALID_MID = 9
    NOT_A_MEMBER = 10
    INVALID_LENGTH = 6
    NOT_AVAILABLE_USER = 7
    NOT_AUTHORIZED_DEVICE = 8
    NOT_AUTHORIZED_SESSION = 14
    INCOMPATIBLE_APP_VERSION = 11
    NOT_READY = 12
    NOT_AVAILABLE_SESSION = 13
    SYSTEM_ERROR = 15
    NO_AVAILABLE_VERIFICATION_METHOD = 16
    NOT_AUTHENTICATED = 17
    INVALID_IDENTITY_CREDENTIAL = 18
    NOT_AVAILABLE_IDENTITY_IDENTIFIER = 19
    INTERNAL_ERROR = 20
    NO_SUCH_IDENTITY_IDENFIER = 21
    DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY = 22
    ILLEGAL_IDENTITY_CREDENTIAL = 23
    UNKNOWN_CHANNEL = 24
    NO_SUCH_MESSAGE_BOX = 25
    NOT_AVAILABLE_MESSAGE_BOX = 26
    CHANNEL_DOES_NOT_MATCH = 27
    NOT_YOUR_MESSAGE = 28
    MESSAGE_DEFINED_ERROR = 29
    USER_CANNOT_ACCEPT_PRESENTS = 30
    USER_NOT_STICKER_OWNER = 32
    MAINTENANCE_ERROR = 33
    ACCOUNT_NOT_MATCHED = 34
    ABUSE_BLOCK = 35
    NOT_FRIEND = 36
    NOT_ALLOWED_CALL = 37
    BLOCK_FRIEND = 38
    INCOMPATIBLE_VOIP_VERSION = 39
    INVALID_SNS_ACCESS_TOKEN = 40
    EXTERNAL_SERVICE_NOT_AVAILABLE = 41
    NOT_ALLOWED_ADD_CONTACT = 42
    NOT_CERTIFICATED = 43
    NOT_ALLOWED_SECONDARY_DEVICE = 44
    INVALID_PIN_CODE = 45
    NOT_FOUND_IDENTITY_CREDENTIAL = 46
    EXCEED_FILE_MAX_SIZE = 47
    EXCEED_DAILY_QUOTA = 48
    NOT_SUPPORT_SEND_FILE = 49
    MUST_UPGRADE = 50
    NOT_AVAILABLE_PIN_CODE_SESSION = 51
    EXPIRED_REVISION = 52
    NOT_YET_PHONE_NUMBER = 54
    BAD_CALL_NUMBER = 55
    UNAVAILABLE_CALL_NUMBER = 56
    NOT_SUPPORT_CALL_SERVICE = 57
    CONGESTION_CONTROL = 58
    NO_BALANCE = 59
    NOT_PERMITTED_CALLER_ID = 60
    NO_CALLER_ID_LIMIT_EXCEEDED = 61
    CALLER_ID_VERIFICATION_REQUIRED = 62
    NO_CALLER_ID_LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED = 63
    MESSAGE_NOT_FOUND = 64
    INVALID_ACCOUNT_MIGRATION_PINCODE_FORMAT = 65
    ACCOUNT_MIGRATION_PINCODE_NOT_MATCHED = 66
    ACCOUNT_MIGRATION_PINCODE_BLOCKED = 67
    INVALID_PASSWORD_FORMAT = 69
    FEATURE_RESTRICTED = 70
    MESSAGE_NOT_DESTRUCTIBLE = 71
    PAID_CALL_REDEEM_FAILED = 72
    PREVENTED_JOIN_BY_TICKET = 73
    SEND_MESSAGE_NOT_PERMITTED_FROM_LINE_AT = 75
    SEND_MESSAGE_NOT_PERMITTED_WHILE_AUTO_REPLY = 76
    SECURITY_CENTER_NOT_VERIFIED = 77
    SECURITY_CENTER_BLOCKED_BY_SETTING = 78
    SECURITY_CENTER_BLOCKED = 79
    TALK_PROXY_EXCEPTION = 80
    E2EE_INVALID_PROTOCOL = 81
    E2EE_RETRY_ENCRYPT = 82
    E2EE_UPDATE_SENDER_KEY = 83
    E2EE_UPDATE_RECEIVER_KEY = 84
    E2EE_INVALID_ARGUMENT = 85
    E2EE_INVALID_VERSION = 86
    E2EE_SENDER_DISABLED = 87
    E2EE_RECEIVER_DISABLED = 88
    E2EE_SENDER_NOT_ALLOWED = 89
    E2EE_RECEIVER_NOT_ALLOWED = 90
    E2EE_RESEND_FAIL = 91
    E2EE_RESEND_OK = 92
    HITOKOTO_BACKUP_NO_AVAILABLE_DATA = 93
    E2EE_UPDATE_PRIMARY_DEVICE = 94
    SUCCESS = 95
    CANCEL = 96
    E2EE_PRIMARY_NOT_SUPPORT = 97
    E2EE_RETRY_PLAIN = 98
    E2EE_RECREATE_GROUP_KEY = 99
    E2EE_GROUP_TOO_MANY_MEMBERS = 100
    SERVER_BUSY = 101
    NOT_ALLOWED_ADD_FOLLOW = 102
    INCOMING_FRIEND_REQUEST_LIMIT = 103
    OUTGOING_FRIEND_REQUEST_LIMIT = 104
    OUTGOING_FRIEND_REQUEST_QUOTA = 105
    DUPLICATED = 106
    BANNED = 107
    NOT_AN_INVITEE = 108
    NOT_AN_OUTSIDER = 109
    EMPTY_GROUP = 111
    EXCEED_FOLLOW_LIMIT = 112
    UNSUPPORTED_ACCOUNT_TYPE = 113

    _VALUES_TO_NAMES = {
        0: "ILLEGAL_ARGUMENT",
        1: "AUTHENTICATION_FAILED",
        2: "DB_FAILED",
        3: "INVALID_STATE",
        4: "EXCESSIVE_ACCESS",
        5: "NOT_FOUND",
        9: "INVALID_MID",
        10: "NOT_A_MEMBER",
        6: "INVALID_LENGTH",
        7: "NOT_AVAILABLE_USER",
        8: "NOT_AUTHORIZED_DEVICE",
        14: "NOT_AUTHORIZED_SESSION",
        11: "INCOMPATIBLE_APP_VERSION",
        12: "NOT_READY",
        13: "NOT_AVAILABLE_SESSION",
        15: "SYSTEM_ERROR",
        16: "NO_AVAILABLE_VERIFICATION_METHOD",
        17: "NOT_AUTHENTICATED",
        18: "INVALID_IDENTITY_CREDENTIAL",
        19: "NOT_AVAILABLE_IDENTITY_IDENTIFIER",
        20: "INTERNAL_ERROR",
        21: "NO_SUCH_IDENTITY_IDENFIER",
        22: "DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY",
        23: "ILLEGAL_IDENTITY_CREDENTIAL",
        24: "UNKNOWN_CHANNEL",
        25: "NO_SUCH_MESSAGE_BOX",
        26: "NOT_AVAILABLE_MESSAGE_BOX",
        27: "CHANNEL_DOES_NOT_MATCH",
        28: "NOT_YOUR_MESSAGE",
        29: "MESSAGE_DEFINED_ERROR",
        30: "USER_CANNOT_ACCEPT_PRESENTS",
        32: "USER_NOT_STICKER_OWNER",
        33: "MAINTENANCE_ERROR",
        34: "ACCOUNT_NOT_MATCHED",
        35: "ABUSE_BLOCK",
        36: "NOT_FRIEND",
        37: "NOT_ALLOWED_CALL",
        38: "BLOCK_FRIEND",
        39: "INCOMPATIBLE_VOIP_VERSION",
        40: "INVALID_SNS_ACCESS_TOKEN",
        41: "EXTERNAL_SERVICE_NOT_AVAILABLE",
        42: "NOT_ALLOWED_ADD_CONTACT",
        43: "NOT_CERTIFICATED",
        44: "NOT_ALLOWED_SECONDARY_DEVICE",
        45: "INVALID_PIN_CODE",
        46: "NOT_FOUND_IDENTITY_CREDENTIAL",
        47: "EXCEED_FILE_MAX_SIZE",
        48: "EXCEED_DAILY_QUOTA",
        49: "NOT_SUPPORT_SEND_FILE",
        50: "MUST_UPGRADE",
        51: "NOT_AVAILABLE_PIN_CODE_SESSION",
        52: "EXPIRED_REVISION",
        54: "NOT_YET_PHONE_NUMBER",
        55: "BAD_CALL_NUMBER",
        56: "UNAVAILABLE_CALL_NUMBER",
        57: "NOT_SUPPORT_CALL_SERVICE",
        58: "CONGESTION_CONTROL",
        59: "NO_BALANCE",
        60: "NOT_PERMITTED_CALLER_ID",
        61: "NO_CALLER_ID_LIMIT_EXCEEDED",
        62: "CALLER_ID_VERIFICATION_REQUIRED",
        63: "NO_CALLER_ID_LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED",
        64: "MESSAGE_NOT_FOUND",
        65: "INVALID_ACCOUNT_MIGRATION_PINCODE_FORMAT",
        66: "ACCOUNT_MIGRATION_PINCODE_NOT_MATCHED",
        67: "ACCOUNT_MIGRATION_PINCODE_BLOCKED",
        69: "INVALID_PASSWORD_FORMAT",
        70: "FEATURE_RESTRICTED",
        71: "MESSAGE_NOT_DESTRUCTIBLE",
        72: "PAID_CALL_REDEEM_FAILED",
        73: "PREVENTED_JOIN_BY_TICKET",
        75: "SEND_MESSAGE_NOT_PERMITTED_FROM_LINE_AT",
        76: "SEND_MESSAGE_NOT_PERMITTED_WHILE_AUTO_REPLY",
        77: "SECURITY_CENTER_NOT_VERIFIED",
        78: "SECURITY_CENTER_BLOCKED_BY_SETTING",
        79: "SECURITY_CENTER_BLOCKED",
        80: "TALK_PROXY_EXCEPTION",
        81: "E2EE_INVALID_PROTOCOL",
        82: "E2EE_RETRY_ENCRYPT",
        83: "E2EE_UPDATE_SENDER_KEY",
        84: "E2EE_UPDATE_RECEIVER_KEY",
        85: "E2EE_INVALID_ARGUMENT",
        86: "E2EE_INVALID_VERSION",
        87: "E2EE_SENDER_DISABLED",
        88: "E2EE_RECEIVER_DISABLED",
        89: "E2EE_SENDER_NOT_ALLOWED",
        90: "E2EE_RECEIVER_NOT_ALLOWED",
        91: "E2EE_RESEND_FAIL",
        92: "E2EE_RESEND_OK",
        93: "HITOKOTO_BACKUP_NO_AVAILABLE_DATA",
        94: "E2EE_UPDATE_PRIMARY_DEVICE",
        95: "SUCCESS",
        96: "CANCEL",
        97: "E2EE_PRIMARY_NOT_SUPPORT",
        98: "E2EE_RETRY_PLAIN",
        99: "E2EE_RECREATE_GROUP_KEY",
        100: "E2EE_GROUP_TOO_MANY_MEMBERS",
        101: "SERVER_BUSY",
        102: "NOT_ALLOWED_ADD_FOLLOW",
        103: "INCOMING_FRIEND_REQUEST_LIMIT",
        104: "OUTGOING_FRIEND_REQUEST_LIMIT",
        105: "OUTGOING_FRIEND_REQUEST_QUOTA",
        106: "DUPLICATED",
        107: "BANNED",
        108: "NOT_AN_INVITEE",
        109: "NOT_AN_OUTSIDER",
        111: "EMPTY_GROUP",
        112: "EXCEED_FOLLOW_LIMIT",
        113: "UNSUPPORTED_ACCOUNT_TYPE",
    }

    _NAMES_TO_VALUES = {
        "ILLEGAL_ARGUMENT": 0,
        "AUTHENTICATION_FAILED": 1,
        "DB_FAILED": 2,
        "INVALID_STATE": 3,
        "EXCESSIVE_ACCESS": 4,
        "NOT_FOUND": 5,
        "INVALID_MID": 9,
        "NOT_A_MEMBER": 10,
        "INVALID_LENGTH": 6,
        "NOT_AVAILABLE_USER": 7,
        "NOT_AUTHORIZED_DEVICE": 8,
        "NOT_AUTHORIZED_SESSION": 14,
        "INCOMPATIBLE_APP_VERSION": 11,
        "NOT_READY": 12,
        "NOT_AVAILABLE_SESSION": 13,
        "SYSTEM_ERROR": 15,
        "NO_AVAILABLE_VERIFICATION_METHOD": 16,
        "NOT_AUTHENTICATED": 17,
        "INVALID_IDENTITY_CREDENTIAL": 18,
        "NOT_AVAILABLE_IDENTITY_IDENTIFIER": 19,
        "INTERNAL_ERROR": 20,
        "NO_SUCH_IDENTITY_IDENFIER": 21,
        "DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY": 22,
        "ILLEGAL_IDENTITY_CREDENTIAL": 23,
        "UNKNOWN_CHANNEL": 24,
        "NO_SUCH_MESSAGE_BOX": 25,
        "NOT_AVAILABLE_MESSAGE_BOX": 26,
        "CHANNEL_DOES_NOT_MATCH": 27,
        "NOT_YOUR_MESSAGE": 28,
        "MESSAGE_DEFINED_ERROR": 29,
        "USER_CANNOT_ACCEPT_PRESENTS": 30,
        "USER_NOT_STICKER_OWNER": 32,
        "MAINTENANCE_ERROR": 33,
        "ACCOUNT_NOT_MATCHED": 34,
        "ABUSE_BLOCK": 35,
        "NOT_FRIEND": 36,
        "NOT_ALLOWED_CALL": 37,
        "BLOCK_FRIEND": 38,
        "INCOMPATIBLE_VOIP_VERSION": 39,
        "INVALID_SNS_ACCESS_TOKEN": 40,
        "EXTERNAL_SERVICE_NOT_AVAILABLE": 41,
        "NOT_ALLOWED_ADD_CONTACT": 42,
        "NOT_CERTIFICATED": 43,
        "NOT_ALLOWED_SECONDARY_DEVICE": 44,
        "INVALID_PIN_CODE": 45,
        "NOT_FOUND_IDENTITY_CREDENTIAL": 46,
        "EXCEED_FILE_MAX_SIZE": 47,
        "EXCEED_DAILY_QUOTA": 48,
        "NOT_SUPPORT_SEND_FILE": 49,
        "MUST_UPGRADE": 50,
        "NOT_AVAILABLE_PIN_CODE_SESSION": 51,
        "EXPIRED_REVISION": 52,
        "NOT_YET_PHONE_NUMBER": 54,
        "BAD_CALL_NUMBER": 55,
        "UNAVAILABLE_CALL_NUMBER": 56,
        "NOT_SUPPORT_CALL_SERVICE": 57,
        "CONGESTION_CONTROL": 58,
        "NO_BALANCE": 59,
        "NOT_PERMITTED_CALLER_ID": 60,
        "NO_CALLER_ID_LIMIT_EXCEEDED": 61,
        "CALLER_ID_VERIFICATION_REQUIRED": 62,
        "NO_CALLER_ID_LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED": 63,
        "MESSAGE_NOT_FOUND": 64,
        "INVALID_ACCOUNT_MIGRATION_PINCODE_FORMAT": 65,
        "ACCOUNT_MIGRATION_PINCODE_NOT_MATCHED": 66,
        "ACCOUNT_MIGRATION_PINCODE_BLOCKED": 67,
        "INVALID_PASSWORD_FORMAT": 69,
        "FEATURE_RESTRICTED": 70,
        "MESSAGE_NOT_DESTRUCTIBLE": 71,
        "PAID_CALL_REDEEM_FAILED": 72,
        "PREVENTED_JOIN_BY_TICKET": 73,
        "SEND_MESSAGE_NOT_PERMITTED_FROM_LINE_AT": 75,
        "SEND_MESSAGE_NOT_PERMITTED_WHILE_AUTO_REPLY": 76,
        "SECURITY_CENTER_NOT_VERIFIED": 77,
        "SECURITY_CENTER_BLOCKED_BY_SETTING": 78,
        "SECURITY_CENTER_BLOCKED": 79,
        "TALK_PROXY_EXCEPTION": 80,
        "E2EE_INVALID_PROTOCOL": 81,
        "E2EE_RETRY_ENCRYPT": 82,
        "E2EE_UPDATE_SENDER_KEY": 83,
        "E2EE_UPDATE_RECEIVER_KEY": 84,
        "E2EE_INVALID_ARGUMENT": 85,
        "E2EE_INVALID_VERSION": 86,
        "E2EE_SENDER_DISABLED": 87,
        "E2EE_RECEIVER_DISABLED": 88,
        "E2EE_SENDER_NOT_ALLOWED": 89,
        "E2EE_RECEIVER_NOT_ALLOWED": 90,
        "E2EE_RESEND_FAIL": 91,
        "E2EE_RESEND_OK": 92,
        "HITOKOTO_BACKUP_NO_AVAILABLE_DATA": 93,
        "E2EE_UPDATE_PRIMARY_DEVICE": 94,
        "SUCCESS": 95,
        "CANCEL": 96,
        "E2EE_PRIMARY_NOT_SUPPORT": 97,
        "E2EE_RETRY_PLAIN": 98,
        "E2EE_RECREATE_GROUP_KEY": 99,
        "E2EE_GROUP_TOO_MANY_MEMBERS": 100,
        "SERVER_BUSY": 101,
        "NOT_ALLOWED_ADD_FOLLOW": 102,
        "INCOMING_FRIEND_REQUEST_LIMIT": 103,
        "OUTGOING_FRIEND_REQUEST_LIMIT": 104,
        "OUTGOING_FRIEND_REQUEST_QUOTA": 105,
        "DUPLICATED": 106,
        "BANNED": 107,
        "NOT_AN_INVITEE": 108,
        "NOT_AN_OUTSIDER": 109,
        "EMPTY_GROUP": 111,
        "EXCEED_FOLLOW_LIMIT": 112,
        "UNSUPPORTED_ACCOUNT_TYPE": 113,
    }


class ApplicationType(object):
    IOS = 16
    IOS_RC = 17
    IOS_BETA = 18
    IOS_ALPHA = 19
    ANDROID = 32
    ANDROID_RC = 33
    ANDROID_BETA = 34
    ANDROID_ALPHA = 35
    WAP = 48
    WAP_RC = 49
    WAP_BETA = 50
    WAP_ALPHA = 51
    BOT = 64
    BOT_RC = 65
    BOT_BETA = 66
    BOT_ALPHA = 67
    WEB = 80
    WEB_RC = 81
    WEB_BETA = 82
    WEB_ALPHA = 83
    DESKTOPWIN = 96
    DESKTOPWIN_RC = 97
    DESKTOPWIN_BETA = 98
    DESKTOPWIN_ALPHA = 99
    DESKTOPMAC = 112
    DESKTOPMAC_RC = 113
    DESKTOPMAC_BETA = 114
    DESKTOPMAC_ALPHA = 115
    CHANNELGW = 128
    CHANNELGW_RC = 129
    CHANNELGW_BETA = 130
    CHANNELGW_ALPHA = 131
    CHANNELCP = 144
    CHANNELCP_RC = 145
    CHANNELCP_BETA = 146
    CHANNELCP_ALPHA = 147
    WINPHONE = 160
    WINPHONE_RC = 161
    WINPHONE_BETA = 162
    WINPHONE_ALPHA = 163
    BLACKBERRY = 176
    BLACKBERRY_RC = 177
    BLACKBERRY_BETA = 178
    BLACKBERRY_ALPHA = 179
    WINMETRO = 192
    WINMETRO_RC = 193
    WINMETRO_BETA = 194
    WINMETRO_ALPHA = 195
    S40 = 208
    S40_RC = 209
    S40_BETA = 210
    S40_ALPHA = 211
    CHRONO = 224
    CHRONO_RC = 225
    CHRONO_BETA = 226
    CHRONO_ALPHA = 227
    TIZEN = 256
    TIZEN_RC = 257
    TIZEN_BETA = 258
    TIZEN_ALPHA = 259
    VIRTUAL = 272
    FIREFOXOS = 288
    FIREFOXOS_RC = 289
    FIREFOXOS_BETA = 290
    FIREFOXOS_ALPHA = 291
    IOSIPAD = 304
    IOSIPAD_RC = 305
    IOSIPAD_BETA = 306
    IOSIPAD_ALPHA = 307
    BIZIOS = 320
    BIZIOS_RC = 321
    BIZIOS_BETA = 322
    BIZIOS_ALPHA = 323
    BIZANDROID = 336
    BIZANDROID_RC = 337
    BIZANDROID_BETA = 338
    BIZANDROID_ALPHA = 339
    BIZBOT = 352
    BIZBOT_RC = 353
    BIZBOT_BETA = 354
    BIZBOT_ALPHA = 355
    CHROMEOS = 368
    CHROMEOS_RC = 369
    CHROMEOS_BETA = 370
    CHROMEOS_ALPHA = 371
    ANDROIDLITE = 384
    ANDROIDLITE_RC = 385
    ANDROIDLITE_BETA = 386
    ANDROIDLITE_ALPHA = 387
    WIN10 = 400
    WIN10_RC = 401
    WIN10_BETA = 402
    WIN10_ALPHA = 403
    BIZWEB = 416
    BIZWEB_RC = 417
    BIZWEB_BETA = 418
    BIZWEB_ALPHA = 419
    DUMMYPRIMARY = 432
    DUMMYPRIMARY_RC = 433
    DUMMYPRIMARY_BETA = 434
    DUMMYPRIMARY_ALPHA = 435
    SQUARE = 448
    SQUARE_RC = 449
    SQUARE_BETA = 450
    SQUARE_ALPHA = 451
    INTERNAL = 464
    INTERNAL_RC = 465
    INTERNAL_BETA = 466
    INTERNAL_ALPHA = 467
    CLOVAFRIENDS = 480
    CLOVAFRIENDS_RC = 481
    CLOVAFRIENDS_BETA = 482
    CLOVAFRIENDS_ALPHA = 483
    WATCHOS = 496
    WATCHOS_RC = 497
    WATCHOS_BETA = 498
    WATCHOS_APLHA = 499

    _VALUES_TO_NAMES = {
        16: "IOS",
        17: "IOS_RC",
        18: "IOS_BETA",
        19: "IOS_ALPHA",
        32: "ANDROID",
        33: "ANDROID_RC",
        34: "ANDROID_BETA",
        35: "ANDROID_ALPHA",
        48: "WAP",
        49: "WAP_RC",
        50: "WAP_BETA",
        51: "WAP_ALPHA",
        64: "BOT",
        65: "BOT_RC",
        66: "BOT_BETA",
        67: "BOT_ALPHA",
        80: "WEB",
        81: "WEB_RC",
        82: "WEB_BETA",
        83: "WEB_ALPHA",
        96: "DESKTOPWIN",
        97: "DESKTOPWIN_RC",
        98: "DESKTOPWIN_BETA",
        99: "DESKTOPWIN_ALPHA",
        112: "DESKTOPMAC",
        113: "DESKTOPMAC_RC",
        114: "DESKTOPMAC_BETA",
        115: "DESKTOPMAC_ALPHA",
        128: "CHANNELGW",
        129: "CHANNELGW_RC",
        130: "CHANNELGW_BETA",
        131: "CHANNELGW_ALPHA",
        144: "CHANNELCP",
        145: "CHANNELCP_RC",
        146: "CHANNELCP_BETA",
        147: "CHANNELCP_ALPHA",
        160: "WINPHONE",
        161: "WINPHONE_RC",
        162: "WINPHONE_BETA",
        163: "WINPHONE_ALPHA",
        176: "BLACKBERRY",
        177: "BLACKBERRY_RC",
        178: "BLACKBERRY_BETA",
        179: "BLACKBERRY_ALPHA",
        192: "WINMETRO",
        193: "WINMETRO_RC",
        194: "WINMETRO_BETA",
        195: "WINMETRO_ALPHA",
        208: "S40",
        209: "S40_RC",
        210: "S40_BETA",
        211: "S40_ALPHA",
        224: "CHRONO",
        225: "CHRONO_RC",
        226: "CHRONO_BETA",
        227: "CHRONO_ALPHA",
        256: "TIZEN",
        257: "TIZEN_RC",
        258: "TIZEN_BETA",
        259: "TIZEN_ALPHA",
        272: "VIRTUAL",
        288: "FIREFOXOS",
        289: "FIREFOXOS_RC",
        290: "FIREFOXOS_BETA",
        291: "FIREFOXOS_ALPHA",
        304: "IOSIPAD",
        305: "IOSIPAD_RC",
        306: "IOSIPAD_BETA",
        307: "IOSIPAD_ALPHA",
        320: "BIZIOS",
        321: "BIZIOS_RC",
        322: "BIZIOS_BETA",
        323: "BIZIOS_ALPHA",
        336: "BIZANDROID",
        337: "BIZANDROID_RC",
        338: "BIZANDROID_BETA",
        339: "BIZANDROID_ALPHA",
        352: "BIZBOT",
        353: "BIZBOT_RC",
        354: "BIZBOT_BETA",
        355: "BIZBOT_ALPHA",
        368: "CHROMEOS",
        369: "CHROMEOS_RC",
        370: "CHROMEOS_BETA",
        371: "CHROMEOS_ALPHA",
        384: "ANDROIDLITE",
        385: "ANDROIDLITE_RC",
        386: "ANDROIDLITE_BETA",
        387: "ANDROIDLITE_ALPHA",
        400: "WIN10",
        401: "WIN10_RC",
        402: "WIN10_BETA",
        403: "WIN10_ALPHA",
        416: "BIZWEB",
        417: "BIZWEB_RC",
        418: "BIZWEB_BETA",
        419: "BIZWEB_ALPHA",
        432: "DUMMYPRIMARY",
        433: "DUMMYPRIMARY_RC",
        434: "DUMMYPRIMARY_BETA",
        435: "DUMMYPRIMARY_ALPHA",
        448: "SQUARE",
        449: "SQUARE_RC",
        450: "SQUARE_BETA",
        451: "SQUARE_ALPHA",
        464: "INTERNAL",
        465: "INTERNAL_RC",
        466: "INTERNAL_BETA",
        467: "INTERNAL_ALPHA",
        480: "CLOVAFRIENDS",
        481: "CLOVAFRIENDS_RC",
        482: "CLOVAFRIENDS_BETA",
        483: "CLOVAFRIENDS_ALPHA",
        496: "WATCHOS",
        497: "WATCHOS_RC",
        498: "WATCHOS_BETA",
        499: "WATCHOS_APLHA",
    }

    _NAMES_TO_VALUES = {
        "IOS": 16,
        "IOS_RC": 17,
        "IOS_BETA": 18,
        "IOS_ALPHA": 19,
        "ANDROID": 32,
        "ANDROID_RC": 33,
        "ANDROID_BETA": 34,
        "ANDROID_ALPHA": 35,
        "WAP": 48,
        "WAP_RC": 49,
        "WAP_BETA": 50,
        "WAP_ALPHA": 51,
        "BOT": 64,
        "BOT_RC": 65,
        "BOT_BETA": 66,
        "BOT_ALPHA": 67,
        "WEB": 80,
        "WEB_RC": 81,
        "WEB_BETA": 82,
        "WEB_ALPHA": 83,
        "DESKTOPWIN": 96,
        "DESKTOPWIN_RC": 97,
        "DESKTOPWIN_BETA": 98,
        "DESKTOPWIN_ALPHA": 99,
        "DESKTOPMAC": 112,
        "DESKTOPMAC_RC": 113,
        "DESKTOPMAC_BETA": 114,
        "DESKTOPMAC_ALPHA": 115,
        "CHANNELGW": 128,
        "CHANNELGW_RC": 129,
        "CHANNELGW_BETA": 130,
        "CHANNELGW_ALPHA": 131,
        "CHANNELCP": 144,
        "CHANNELCP_RC": 145,
        "CHANNELCP_BETA": 146,
        "CHANNELCP_ALPHA": 147,
        "WINPHONE": 160,
        "WINPHONE_RC": 161,
        "WINPHONE_BETA": 162,
        "WINPHONE_ALPHA": 163,
        "BLACKBERRY": 176,
        "BLACKBERRY_RC": 177,
        "BLACKBERRY_BETA": 178,
        "BLACKBERRY_ALPHA": 179,
        "WINMETRO": 192,
        "WINMETRO_RC": 193,
        "WINMETRO_BETA": 194,
        "WINMETRO_ALPHA": 195,
        "S40": 208,
        "S40_RC": 209,
        "S40_BETA": 210,
        "S40_ALPHA": 211,
        "CHRONO": 224,
        "CHRONO_RC": 225,
        "CHRONO_BETA": 226,
        "CHRONO_ALPHA": 227,
        "TIZEN": 256,
        "TIZEN_RC": 257,
        "TIZEN_BETA": 258,
        "TIZEN_ALPHA": 259,
        "VIRTUAL": 272,
        "FIREFOXOS": 288,
        "FIREFOXOS_RC": 289,
        "FIREFOXOS_BETA": 290,
        "FIREFOXOS_ALPHA": 291,
        "IOSIPAD": 304,
        "IOSIPAD_RC": 305,
        "IOSIPAD_BETA": 306,
        "IOSIPAD_ALPHA": 307,
        "BIZIOS": 320,
        "BIZIOS_RC": 321,
        "BIZIOS_BETA": 322,
        "BIZIOS_ALPHA": 323,
        "BIZANDROID": 336,
        "BIZANDROID_RC": 337,
        "BIZANDROID_BETA": 338,
        "BIZANDROID_ALPHA": 339,
        "BIZBOT": 352,
        "BIZBOT_RC": 353,
        "BIZBOT_BETA": 354,
        "BIZBOT_ALPHA": 355,
        "CHROMEOS": 368,
        "CHROMEOS_RC": 369,
        "CHROMEOS_BETA": 370,
        "CHROMEOS_ALPHA": 371,
        "ANDROIDLITE": 384,
        "ANDROIDLITE_RC": 385,
        "ANDROIDLITE_BETA": 386,
        "ANDROIDLITE_ALPHA": 387,
        "WIN10": 400,
        "WIN10_RC": 401,
        "WIN10_BETA": 402,
        "WIN10_ALPHA": 403,
        "BIZWEB": 416,
        "BIZWEB_RC": 417,
        "BIZWEB_BETA": 418,
        "BIZWEB_ALPHA": 419,
        "DUMMYPRIMARY": 432,
        "DUMMYPRIMARY_RC": 433,
        "DUMMYPRIMARY_BETA": 434,
        "DUMMYPRIMARY_ALPHA": 435,
        "SQUARE": 448,
        "SQUARE_RC": 449,
        "SQUARE_BETA": 450,
        "SQUARE_ALPHA": 451,
        "INTERNAL": 464,
        "INTERNAL_RC": 465,
        "INTERNAL_BETA": 466,
        "INTERNAL_ALPHA": 467,
        "CLOVAFRIENDS": 480,
        "CLOVAFRIENDS_RC": 481,
        "CLOVAFRIENDS_BETA": 482,
        "CLOVAFRIENDS_ALPHA": 483,
        "WATCHOS": 496,
        "WATCHOS_RC": 497,
        "WATCHOS_BETA": 498,
        "WATCHOS_APLHA": 499,
    }


class TalkException(TException):
    """
    Attributes:
     - code
     - reason
     - parameterMap

    """


    def __init__(self, code=None, reason=None, parameterMap=None,):
        self.code = code
        self.reason = reason
        self.parameterMap = parameterMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.reason = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.parameterMap = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val6 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.parameterMap[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TalkException')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        if self.reason is not None:
            oprot.writeFieldBegin('reason', TType.STRING, 2)
            oprot.writeString(self.reason.encode('utf-8') if sys.version_info[0] == 2 else self.reason)
            oprot.writeFieldEnd()
        if self.parameterMap is not None:
            oprot.writeFieldBegin('parameterMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameterMap))
            for kiter7, viter8 in self.parameterMap.items():
                oprot.writeString(kiter7.encode('utf-8') if sys.version_info[0] == 2 else kiter7)
                oprot.writeString(viter8.encode('utf-8') if sys.version_info[0] == 2 else viter8)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BeaconTouchActions(object):
    """
    Attributes:
     - actions

    """


    def __init__(self, actions=None,):
        self.actions = actions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.actions = []
                    (_etype12, _size9) = iprot.readListBegin()
                    for _i13 in range(_size9):
                        _elem14 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.actions.append(_elem14)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BeaconTouchActions')
        if self.actions is not None:
            oprot.writeFieldBegin('actions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.actions))
            for iter15 in self.actions:
                oprot.writeString(iter15.encode('utf-8') if sys.version_info[0] == 2 else iter15)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BeaconLayerInfoAndActions(object):
    """
    Attributes:
     - pictureUrl
     - label
     - text
     - actions
     - showOrConditions
     - showConditions
     - timeToHide

    """


    def __init__(self, pictureUrl=None, label=None, text=None, actions=None, showOrConditions=None, showConditions=None, timeToHide=None,):
        self.pictureUrl = pictureUrl
        self.label = label
        self.text = text
        self.actions = actions
        self.showOrConditions = showOrConditions
        self.showConditions = showConditions
        self.timeToHide = timeToHide

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pictureUrl = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.label = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.text = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.actions = []
                    (_etype19, _size16) = iprot.readListBegin()
                    for _i20 in range(_size16):
                        _elem21 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.actions.append(_elem21)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.showOrConditions = []
                    (_etype25, _size22) = iprot.readListBegin()
                    for _i26 in range(_size22):
                        _elem27 = BeaconCondition()
                        _elem27.read(iprot)
                        self.showOrConditions.append(_elem27)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.showConditions = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = BeaconCondition()
                        _elem33.read(iprot)
                        self.showConditions.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timeToHide = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BeaconLayerInfoAndActions')
        if self.pictureUrl is not None:
            oprot.writeFieldBegin('pictureUrl', TType.STRING, 1)
            oprot.writeString(self.pictureUrl.encode('utf-8') if sys.version_info[0] == 2 else self.pictureUrl)
            oprot.writeFieldEnd()
        if self.label is not None:
            oprot.writeFieldBegin('label', TType.STRING, 2)
            oprot.writeString(self.label.encode('utf-8') if sys.version_info[0] == 2 else self.label)
            oprot.writeFieldEnd()
        if self.text is not None:
            oprot.writeFieldBegin('text', TType.STRING, 3)
            oprot.writeString(self.text.encode('utf-8') if sys.version_info[0] == 2 else self.text)
            oprot.writeFieldEnd()
        if self.actions is not None:
            oprot.writeFieldBegin('actions', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.actions))
            for iter34 in self.actions:
                oprot.writeString(iter34.encode('utf-8') if sys.version_info[0] == 2 else iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.showOrConditions is not None:
            oprot.writeFieldBegin('showOrConditions', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.showOrConditions))
            for iter35 in self.showOrConditions:
                iter35.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.showConditions is not None:
            oprot.writeFieldBegin('showConditions', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.showConditions))
            for iter36 in self.showConditions:
                iter36.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timeToHide is not None:
            oprot.writeFieldBegin('timeToHide', TType.I64, 7)
            oprot.writeI64(self.timeToHide)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BeaconBackgroundNotification(object):
    """
    Attributes:
     - actionInterval
     - actionAndConditions
     - actionDelay
     - actionConditions

    """


    def __init__(self, actionInterval=None, actionAndConditions=None, actionDelay=None, actionConditions=None,):
        self.actionInterval = actionInterval
        self.actionAndConditions = actionAndConditions
        self.actionDelay = actionDelay
        self.actionConditions = actionConditions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.actionInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.actionAndConditions = []
                    (_etype40, _size37) = iprot.readListBegin()
                    for _i41 in range(_size37):
                        _elem42 = BeaconCondition()
                        _elem42.read(iprot)
                        self.actionAndConditions.append(_elem42)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.actionDelay = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.actionConditions = []
                    (_etype46, _size43) = iprot.readListBegin()
                    for _i47 in range(_size43):
                        _elem48 = BeaconCondition()
                        _elem48.read(iprot)
                        self.actionConditions.append(_elem48)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BeaconBackgroundNotification')
        if self.actionInterval is not None:
            oprot.writeFieldBegin('actionInterval', TType.I64, 1)
            oprot.writeI64(self.actionInterval)
            oprot.writeFieldEnd()
        if self.actionAndConditions is not None:
            oprot.writeFieldBegin('actionAndConditions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.actionAndConditions))
            for iter49 in self.actionAndConditions:
                iter49.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.actionDelay is not None:
            oprot.writeFieldBegin('actionDelay', TType.I64, 3)
            oprot.writeI64(self.actionDelay)
            oprot.writeFieldEnd()
        if self.actionConditions is not None:
            oprot.writeFieldBegin('actionConditions', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.actionConditions))
            for iter50 in self.actionConditions:
                iter50.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BeaconCondition(object):
    """
    Attributes:
     - inFriends
     - notInFriends
     - termsAgreed

    """


    def __init__(self, inFriends=None, notInFriends=None, termsAgreed=None,):
        self.inFriends = inFriends
        self.notInFriends = notInFriends
        self.termsAgreed = termsAgreed

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.inFriends = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.notInFriends = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.termsAgreed = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BeaconCondition')
        if self.inFriends is not None:
            oprot.writeFieldBegin('inFriends', TType.STRING, 1)
            oprot.writeString(self.inFriends.encode('utf-8') if sys.version_info[0] == 2 else self.inFriends)
            oprot.writeFieldEnd()
        if self.notInFriends is not None:
            oprot.writeFieldBegin('notInFriends', TType.STRING, 2)
            oprot.writeString(self.notInFriends.encode('utf-8') if sys.version_info[0] == 2 else self.notInFriends)
            oprot.writeFieldEnd()
        if self.termsAgreed is not None:
            oprot.writeFieldBegin('termsAgreed', TType.BOOL, 3)
            oprot.writeBool(self.termsAgreed)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NotifyBannerShowing(object):
    """
    Attributes:
     - hwid
     - secureMessage
     - applicationType
     - applicationVersion
     - userSessionId
     - actionId
     - screen
     - bannerStartedAt
     - bannerShownFor

    """


    def __init__(self, hwid=None, secureMessage=None, applicationType=None, applicationVersion=None, userSessionId=None, actionId=None, screen=None, bannerStartedAt=None, bannerShownFor=None,):
        self.hwid = hwid
        self.secureMessage = secureMessage
        self.applicationType = applicationType
        self.applicationVersion = applicationVersion
        self.userSessionId = userSessionId
        self.actionId = actionId
        self.screen = screen
        self.bannerStartedAt = bannerStartedAt
        self.bannerShownFor = bannerShownFor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hwid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.secureMessage = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.applicationType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.applicationVersion = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.userSessionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.actionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.screen = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.bannerStartedAt = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.bannerShownFor = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NotifyBannerShowing')
        if self.hwid is not None:
            oprot.writeFieldBegin('hwid', TType.STRING, 1)
            oprot.writeString(self.hwid.encode('utf-8') if sys.version_info[0] == 2 else self.hwid)
            oprot.writeFieldEnd()
        if self.secureMessage is not None:
            oprot.writeFieldBegin('secureMessage', TType.STRING, 2)
            oprot.writeString(self.secureMessage.encode('utf-8') if sys.version_info[0] == 2 else self.secureMessage)
            oprot.writeFieldEnd()
        if self.applicationType is not None:
            oprot.writeFieldBegin('applicationType', TType.I32, 3)
            oprot.writeI32(self.applicationType)
            oprot.writeFieldEnd()
        if self.applicationVersion is not None:
            oprot.writeFieldBegin('applicationVersion', TType.STRING, 4)
            oprot.writeString(self.applicationVersion.encode('utf-8') if sys.version_info[0] == 2 else self.applicationVersion)
            oprot.writeFieldEnd()
        if self.userSessionId is not None:
            oprot.writeFieldBegin('userSessionId', TType.STRING, 5)
            oprot.writeString(self.userSessionId.encode('utf-8') if sys.version_info[0] == 2 else self.userSessionId)
            oprot.writeFieldEnd()
        if self.actionId is not None:
            oprot.writeFieldBegin('actionId', TType.I64, 6)
            oprot.writeI64(self.actionId)
            oprot.writeFieldEnd()
        if self.screen is not None:
            oprot.writeFieldBegin('screen', TType.STRING, 7)
            oprot.writeString(self.screen.encode('utf-8') if sys.version_info[0] == 2 else self.screen)
            oprot.writeFieldEnd()
        if self.bannerStartedAt is not None:
            oprot.writeFieldBegin('bannerStartedAt', TType.I64, 8)
            oprot.writeI64(self.bannerStartedAt)
            oprot.writeFieldEnd()
        if self.bannerShownFor is not None:
            oprot.writeFieldBegin('bannerShownFor', TType.I64, 9)
            oprot.writeI64(self.bannerShownFor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class QueryBeaconActions(object):
    """
    Attributes:
     - hwid
     - secureMessage
     - applicationType
     - applicationVersion
     - lang
     - region
     - modelname

    """


    def __init__(self, hwid=None, secureMessage=None, applicationType=None, applicationVersion=None, lang=None, region=None, modelname=None,):
        self.hwid = hwid
        self.secureMessage = secureMessage
        self.applicationType = applicationType
        self.applicationVersion = applicationVersion
        self.lang = lang
        self.region = region
        self.modelname = modelname

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hwid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.secureMessage = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.applicationType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.applicationVersion = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.lang = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.region = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.modelname = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('QueryBeaconActions')
        if self.hwid is not None:
            oprot.writeFieldBegin('hwid', TType.STRING, 1)
            oprot.writeString(self.hwid.encode('utf-8') if sys.version_info[0] == 2 else self.hwid)
            oprot.writeFieldEnd()
        if self.secureMessage is not None:
            oprot.writeFieldBegin('secureMessage', TType.STRING, 2)
            oprot.writeString(self.secureMessage.encode('utf-8') if sys.version_info[0] == 2 else self.secureMessage)
            oprot.writeFieldEnd()
        if self.applicationType is not None:
            oprot.writeFieldBegin('applicationType', TType.I32, 3)
            oprot.writeI32(self.applicationType)
            oprot.writeFieldEnd()
        if self.applicationVersion is not None:
            oprot.writeFieldBegin('applicationVersion', TType.STRING, 4)
            oprot.writeString(self.applicationVersion.encode('utf-8') if sys.version_info[0] == 2 else self.applicationVersion)
            oprot.writeFieldEnd()
        if self.lang is not None:
            oprot.writeFieldBegin('lang', TType.STRING, 5)
            oprot.writeString(self.lang.encode('utf-8') if sys.version_info[0] == 2 else self.lang)
            oprot.writeFieldEnd()
        if self.region is not None:
            oprot.writeFieldBegin('region', TType.STRING, 6)
            oprot.writeString(self.region.encode('utf-8') if sys.version_info[0] == 2 else self.region)
            oprot.writeFieldEnd()
        if self.modelname is not None:
            oprot.writeFieldBegin('modelname', TType.STRING, 7)
            oprot.writeString(self.modelname.encode('utf-8') if sys.version_info[0] == 2 else self.modelname)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class notifyBannerTapped(object):
    """
    Attributes:
     - hwid
     - secureMessage
     - applicationType
     - applicationVersion
     - userSessionId
     - actionId
     - screen
     - bannerTappedAt
     - bannerTermAgreed

    """


    def __init__(self, hwid=None, secureMessage=None, applicationType=None, applicationVersion=None, userSessionId=None, actionId=None, screen=None, bannerTappedAt=None, bannerTermAgreed=None,):
        self.hwid = hwid
        self.secureMessage = secureMessage
        self.applicationType = applicationType
        self.applicationVersion = applicationVersion
        self.userSessionId = userSessionId
        self.actionId = actionId
        self.screen = screen
        self.bannerTappedAt = bannerTappedAt
        self.bannerTermAgreed = bannerTermAgreed

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hwid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.secureMessage = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.applicationType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.applicationVersion = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.userSessionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.actionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.screen = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.bannerTappedAt = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.bannerTermAgreed = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('notifyBannerTapped')
        if self.hwid is not None:
            oprot.writeFieldBegin('hwid', TType.STRING, 1)
            oprot.writeString(self.hwid.encode('utf-8') if sys.version_info[0] == 2 else self.hwid)
            oprot.writeFieldEnd()
        if self.secureMessage is not None:
            oprot.writeFieldBegin('secureMessage', TType.STRING, 2)
            oprot.writeString(self.secureMessage.encode('utf-8') if sys.version_info[0] == 2 else self.secureMessage)
            oprot.writeFieldEnd()
        if self.applicationType is not None:
            oprot.writeFieldBegin('applicationType', TType.I32, 3)
            oprot.writeI32(self.applicationType)
            oprot.writeFieldEnd()
        if self.applicationVersion is not None:
            oprot.writeFieldBegin('applicationVersion', TType.STRING, 4)
            oprot.writeString(self.applicationVersion.encode('utf-8') if sys.version_info[0] == 2 else self.applicationVersion)
            oprot.writeFieldEnd()
        if self.userSessionId is not None:
            oprot.writeFieldBegin('userSessionId', TType.STRING, 5)
            oprot.writeString(self.userSessionId.encode('utf-8') if sys.version_info[0] == 2 else self.userSessionId)
            oprot.writeFieldEnd()
        if self.actionId is not None:
            oprot.writeFieldBegin('actionId', TType.I64, 6)
            oprot.writeI64(self.actionId)
            oprot.writeFieldEnd()
        if self.screen is not None:
            oprot.writeFieldBegin('screen', TType.STRING, 7)
            oprot.writeString(self.screen.encode('utf-8') if sys.version_info[0] == 2 else self.screen)
            oprot.writeFieldEnd()
        if self.bannerTappedAt is not None:
            oprot.writeFieldBegin('bannerTappedAt', TType.I64, 8)
            oprot.writeI64(self.bannerTappedAt)
            oprot.writeFieldEnd()
        if self.bannerTermAgreed is not None:
            oprot.writeFieldBegin('bannerTermAgreed', TType.BOOL, 9)
            oprot.writeBool(self.bannerTermAgreed)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class BeaconQueryResponse(object):
    """
    Attributes:
     - deprecated_actionUrls
     - cacheTtl
     - touchActions
     - layerInfoAndActions
     - backgroundEnteringNotification
     - backgroundLeavingNotification
     - group
     - major
     - minor
     - effectiveRange
     - channelWhiteList
     - actionId
     - stayReportInterval
     - leaveThresholdTime
     - touchThreshold
     - cutoffThreshold

    """


    def __init__(self, deprecated_actionUrls=None, cacheTtl=None, touchActions=None, layerInfoAndActions=None, backgroundEnteringNotification=None, backgroundLeavingNotification=None, group=None, major=None, minor=None, effectiveRange=None, channelWhiteList=None, actionId=None, stayReportInterval=None, leaveThresholdTime=None, touchThreshold=None, cutoffThreshold=None,):
        self.deprecated_actionUrls = deprecated_actionUrls
        self.cacheTtl = cacheTtl
        self.touchActions = touchActions
        self.layerInfoAndActions = layerInfoAndActions
        self.backgroundEnteringNotification = backgroundEnteringNotification
        self.backgroundLeavingNotification = backgroundLeavingNotification
        self.group = group
        self.major = major
        self.minor = minor
        self.effectiveRange = effectiveRange
        self.channelWhiteList = channelWhiteList
        self.actionId = actionId
        self.stayReportInterval = stayReportInterval
        self.leaveThresholdTime = leaveThresholdTime
        self.touchThreshold = touchThreshold
        self.cutoffThreshold = cutoffThreshold

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.LIST:
                    self.deprecated_actionUrls = []
                    (_etype54, _size51) = iprot.readListBegin()
                    for _i55 in range(_size51):
                        _elem56 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.deprecated_actionUrls.append(_elem56)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.cacheTtl = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.touchActions = BeaconTouchActions()
                    self.touchActions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.layerInfoAndActions = BeaconLayerInfoAndActions()
                    self.layerInfoAndActions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.backgroundEnteringNotification = BeaconBackgroundNotification()
                    self.backgroundEnteringNotification.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.backgroundLeavingNotification = BeaconBackgroundNotification()
                    self.backgroundLeavingNotification.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.group = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.major = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.minor = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.effectiveRange = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.LIST:
                    self.channelWhiteList = []
                    (_etype60, _size57) = iprot.readListBegin()
                    for _i61 in range(_size57):
                        _elem62 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.channelWhiteList.append(_elem62)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I64:
                    self.actionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.stayReportInterval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I64:
                    self.leaveThresholdTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.DOUBLE:
                    self.touchThreshold = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I16:
                    self.cutoffThreshold = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('BeaconQueryResponse')
        if self.deprecated_actionUrls is not None:
            oprot.writeFieldBegin('deprecated_actionUrls', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.deprecated_actionUrls))
            for iter63 in self.deprecated_actionUrls:
                oprot.writeString(iter63.encode('utf-8') if sys.version_info[0] == 2 else iter63)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cacheTtl is not None:
            oprot.writeFieldBegin('cacheTtl', TType.I64, 3)
            oprot.writeI64(self.cacheTtl)
            oprot.writeFieldEnd()
        if self.touchActions is not None:
            oprot.writeFieldBegin('touchActions', TType.STRUCT, 4)
            self.touchActions.write(oprot)
            oprot.writeFieldEnd()
        if self.layerInfoAndActions is not None:
            oprot.writeFieldBegin('layerInfoAndActions', TType.STRUCT, 5)
            self.layerInfoAndActions.write(oprot)
            oprot.writeFieldEnd()
        if self.backgroundEnteringNotification is not None:
            oprot.writeFieldBegin('backgroundEnteringNotification', TType.STRUCT, 6)
            self.backgroundEnteringNotification.write(oprot)
            oprot.writeFieldEnd()
        if self.backgroundLeavingNotification is not None:
            oprot.writeFieldBegin('backgroundLeavingNotification', TType.STRUCT, 7)
            self.backgroundLeavingNotification.write(oprot)
            oprot.writeFieldEnd()
        if self.group is not None:
            oprot.writeFieldBegin('group', TType.STRING, 8)
            oprot.writeString(self.group.encode('utf-8') if sys.version_info[0] == 2 else self.group)
            oprot.writeFieldEnd()
        if self.major is not None:
            oprot.writeFieldBegin('major', TType.STRING, 9)
            oprot.writeString(self.major.encode('utf-8') if sys.version_info[0] == 2 else self.major)
            oprot.writeFieldEnd()
        if self.minor is not None:
            oprot.writeFieldBegin('minor', TType.STRING, 10)
            oprot.writeString(self.minor.encode('utf-8') if sys.version_info[0] == 2 else self.minor)
            oprot.writeFieldEnd()
        if self.effectiveRange is not None:
            oprot.writeFieldBegin('effectiveRange', TType.DOUBLE, 11)
            oprot.writeDouble(self.effectiveRange)
            oprot.writeFieldEnd()
        if self.channelWhiteList is not None:
            oprot.writeFieldBegin('channelWhiteList', TType.LIST, 12)
            oprot.writeListBegin(TType.STRING, len(self.channelWhiteList))
            for iter64 in self.channelWhiteList:
                oprot.writeString(iter64.encode('utf-8') if sys.version_info[0] == 2 else iter64)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.actionId is not None:
            oprot.writeFieldBegin('actionId', TType.I64, 13)
            oprot.writeI64(self.actionId)
            oprot.writeFieldEnd()
        if self.stayReportInterval is not None:
            oprot.writeFieldBegin('stayReportInterval', TType.I64, 14)
            oprot.writeI64(self.stayReportInterval)
            oprot.writeFieldEnd()
        if self.leaveThresholdTime is not None:
            oprot.writeFieldBegin('leaveThresholdTime', TType.I64, 15)
            oprot.writeI64(self.leaveThresholdTime)
            oprot.writeFieldEnd()
        if self.touchThreshold is not None:
            oprot.writeFieldBegin('touchThreshold', TType.DOUBLE, 17)
            oprot.writeDouble(self.touchThreshold)
            oprot.writeFieldEnd()
        if self.cutoffThreshold is not None:
            oprot.writeFieldBegin('cutoffThreshold', TType.I16, 18)
            oprot.writeI16(self.cutoffThreshold)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TalkException)
TalkException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
    (2, TType.STRING, 'reason', 'UTF8', None, ),  # 2
    (3, TType.MAP, 'parameterMap', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
)
all_structs.append(BeaconTouchActions)
BeaconTouchActions.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'actions', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(BeaconLayerInfoAndActions)
BeaconLayerInfoAndActions.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pictureUrl', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'label', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'text', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'actions', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'showOrConditions', (TType.STRUCT, [BeaconCondition, None], False), None, ),  # 5
    (6, TType.LIST, 'showConditions', (TType.STRUCT, [BeaconCondition, None], False), None, ),  # 6
    (7, TType.I64, 'timeToHide', None, None, ),  # 7
)
all_structs.append(BeaconBackgroundNotification)
BeaconBackgroundNotification.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'actionInterval', None, None, ),  # 1
    (2, TType.LIST, 'actionAndConditions', (TType.STRUCT, [BeaconCondition, None], False), None, ),  # 2
    (3, TType.I64, 'actionDelay', None, None, ),  # 3
    (4, TType.LIST, 'actionConditions', (TType.STRUCT, [BeaconCondition, None], False), None, ),  # 4
)
all_structs.append(BeaconCondition)
BeaconCondition.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'inFriends', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'notInFriends', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'termsAgreed', None, None, ),  # 3
)
all_structs.append(NotifyBannerShowing)
NotifyBannerShowing.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hwid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'secureMessage', 'UTF8', None, ),  # 2
    (3, TType.I32, 'applicationType', None, None, ),  # 3
    (4, TType.STRING, 'applicationVersion', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'userSessionId', 'UTF8', None, ),  # 5
    (6, TType.I64, 'actionId', None, None, ),  # 6
    (7, TType.STRING, 'screen', 'UTF8', None, ),  # 7
    (8, TType.I64, 'bannerStartedAt', None, None, ),  # 8
    (9, TType.I64, 'bannerShownFor', None, None, ),  # 9
)
all_structs.append(QueryBeaconActions)
QueryBeaconActions.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hwid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'secureMessage', 'UTF8', None, ),  # 2
    (3, TType.I32, 'applicationType', None, None, ),  # 3
    (4, TType.STRING, 'applicationVersion', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'lang', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'region', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'modelname', 'UTF8', None, ),  # 7
)
all_structs.append(notifyBannerTapped)
notifyBannerTapped.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hwid', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'secureMessage', 'UTF8', None, ),  # 2
    (3, TType.I32, 'applicationType', None, None, ),  # 3
    (4, TType.STRING, 'applicationVersion', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'userSessionId', 'UTF8', None, ),  # 5
    (6, TType.I64, 'actionId', None, None, ),  # 6
    (7, TType.STRING, 'screen', 'UTF8', None, ),  # 7
    (8, TType.I64, 'bannerTappedAt', None, None, ),  # 8
    (9, TType.BOOL, 'bannerTermAgreed', None, None, ),  # 9
)
all_structs.append(BeaconQueryResponse)
BeaconQueryResponse.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.LIST, 'deprecated_actionUrls', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'cacheTtl', None, None, ),  # 3
    (4, TType.STRUCT, 'touchActions', [BeaconTouchActions, None], None, ),  # 4
    (5, TType.STRUCT, 'layerInfoAndActions', [BeaconLayerInfoAndActions, None], None, ),  # 5
    (6, TType.STRUCT, 'backgroundEnteringNotification', [BeaconBackgroundNotification, None], None, ),  # 6
    (7, TType.STRUCT, 'backgroundLeavingNotification', [BeaconBackgroundNotification, None], None, ),  # 7
    (8, TType.STRING, 'group', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'major', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'minor', 'UTF8', None, ),  # 10
    (11, TType.DOUBLE, 'effectiveRange', None, None, ),  # 11
    (12, TType.LIST, 'channelWhiteList', (TType.STRING, 'UTF8', False), None, ),  # 12
    (13, TType.I64, 'actionId', None, None, ),  # 13
    (14, TType.I64, 'stayReportInterval', None, None, ),  # 14
    (15, TType.I64, 'leaveThresholdTime', None, None, ),  # 15
    None,  # 16
    (17, TType.DOUBLE, 'touchThreshold', None, None, ),  # 17
    (18, TType.I16, 'cutoffThreshold', None, None, ),  # 18
)
fix_spec(all_structs)
del all_structs
