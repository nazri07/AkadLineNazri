#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class AuthLoginVersion:
  UNKNOWN = 0
  V1 = 1
  V2 = 2

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "V1",
    2: "V2",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "V1": 1,
    "V2": 2,
  }

class AuthKeyVersion:
  UNKNOWN = 0
  V1 = 1

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "V1",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "V1": 1,
  }

class ErrorCode:
  ILLEGAL_ARGUMENT = 0
  AUTHENTICATION_FAILED = 1
  DB_FAILED = 2
  INVALID_STATE = 3
  EXCESSIVE_ACCESS = 4
  NOT_FOUND = 5
  INVALID_MID = 9
  NOT_A_MEMBER = 10
  INVALID_LENGTH = 6
  NOT_AVAILABLE_USER = 7
  NOT_AUTHORIZED_DEVICE = 8
  NOT_AUTHORIZED_SESSION = 14
  INCOMPATIBLE_APP_VERSION = 11
  NOT_READY = 12
  NOT_AVAILABLE_SESSION = 13
  SYSTEM_ERROR = 15
  NO_AVAILABLE_VERIFICATION_METHOD = 16
  NOT_AUTHENTICATED = 17
  INVALID_IDENTITY_CREDENTIAL = 18
  NOT_AVAILABLE_IDENTITY_IDENTIFIER = 19
  INTERNAL_ERROR = 20
  NO_SUCH_IDENTITY_IDENFIER = 21
  DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY = 22
  ILLEGAL_IDENTITY_CREDENTIAL = 23
  UNKNOWN_CHANNEL = 24
  NO_SUCH_MESSAGE_BOX = 25
  NOT_AVAILABLE_MESSAGE_BOX = 26
  CHANNEL_DOES_NOT_MATCH = 27
  NOT_YOUR_MESSAGE = 28
  MESSAGE_DEFINED_ERROR = 29
  USER_CANNOT_ACCEPT_PRESENTS = 30
  USER_NOT_STICKER_OWNER = 32
  MAINTENANCE_ERROR = 33
  ACCOUNT_NOT_MATCHED = 34
  ABUSE_BLOCK = 35
  NOT_FRIEND = 36
  NOT_ALLOWED_CALL = 37
  BLOCK_FRIEND = 38
  INCOMPATIBLE_VOIP_VERSION = 39
  INVALID_SNS_ACCESS_TOKEN = 40
  EXTERNAL_SERVICE_NOT_AVAILABLE = 41
  NOT_ALLOWED_ADD_CONTACT = 42
  NOT_CERTIFICATED = 43
  NOT_ALLOWED_SECONDARY_DEVICE = 44
  INVALID_PIN_CODE = 45
  NOT_FOUND_IDENTITY_CREDENTIAL = 46
  EXCEED_FILE_MAX_SIZE = 47
  EXCEED_DAILY_QUOTA = 48
  NOT_SUPPORT_SEND_FILE = 49
  MUST_UPGRADE = 50
  NOT_AVAILABLE_PIN_CODE_SESSION = 51
  EXPIRED_REVISION = 52
  NOT_YET_PHONE_NUMBER = 54
  BAD_CALL_NUMBER = 55
  UNAVAILABLE_CALL_NUMBER = 56
  NOT_SUPPORT_CALL_SERVICE = 57
  CONGESTION_CONTROL = 58
  NO_BALANCE = 59
  NOT_PERMITTED_CALLER_ID = 60
  NO_CALLER_ID_LIMIT_EXCEEDED = 61
  CALLER_ID_VERIFICATION_REQUIRED = 62
  NO_CALLER_ID_LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED = 63
  MESSAGE_NOT_FOUND = 64
  INVALID_ACCOUNT_MIGRATION_PINCODE_FORMAT = 65
  ACCOUNT_MIGRATION_PINCODE_NOT_MATCHED = 66
  ACCOUNT_MIGRATION_PINCODE_BLOCKED = 67
  INVALID_PASSWORD_FORMAT = 69
  FEATURE_RESTRICTED = 70
  MESSAGE_NOT_DESTRUCTIBLE = 71
  PAID_CALL_REDEEM_FAILED = 72
  PREVENTED_JOIN_BY_TICKET = 73
  SEND_MESSAGE_NOT_PERMITTED_FROM_LINE_AT = 75
  SEND_MESSAGE_NOT_PERMITTED_WHILE_AUTO_REPLY = 76
  SECURITY_CENTER_NOT_VERIFIED = 77
  SECURITY_CENTER_BLOCKED_BY_SETTING = 78
  SECURITY_CENTER_BLOCKED = 79
  TALK_PROXY_EXCEPTION = 80
  E2EE_INVALID_PROTOCOL = 81
  E2EE_RETRY_ENCRYPT = 82
  E2EE_UPDATE_SENDER_KEY = 83
  E2EE_UPDATE_RECEIVER_KEY = 84
  E2EE_INVALID_ARGUMENT = 85
  E2EE_INVALID_VERSION = 86
  E2EE_SENDER_DISABLED = 87
  E2EE_RECEIVER_DISABLED = 88
  E2EE_SENDER_NOT_ALLOWED = 89
  E2EE_RECEIVER_NOT_ALLOWED = 90
  E2EE_RESEND_FAIL = 91
  E2EE_RESEND_OK = 92
  HITOKOTO_BACKUP_NO_AVAILABLE_DATA = 93
  E2EE_UPDATE_PRIMARY_DEVICE = 94
  SUCCESS = 95
  CANCEL = 96
  E2EE_PRIMARY_NOT_SUPPORT = 97
  E2EE_RETRY_PLAIN = 98
  E2EE_RECREATE_GROUP_KEY = 99
  E2EE_GROUP_TOO_MANY_MEMBERS = 100
  SERVER_BUSY = 101
  NOT_ALLOWED_ADD_FOLLOW = 102
  INCOMING_FRIEND_REQUEST_LIMIT = 103
  OUTGOING_FRIEND_REQUEST_LIMIT = 104
  OUTGOING_FRIEND_REQUEST_QUOTA = 105
  DUPLICATED = 106
  BANNED = 107
  NOT_AN_INVITEE = 108
  NOT_AN_OUTSIDER = 109
  EMPTY_GROUP = 111
  EXCEED_FOLLOW_LIMIT = 112
  UNSUPPORTED_ACCOUNT_TYPE = 113

  _VALUES_TO_NAMES = {
    0: "ILLEGAL_ARGUMENT",
    1: "AUTHENTICATION_FAILED",
    2: "DB_FAILED",
    3: "INVALID_STATE",
    4: "EXCESSIVE_ACCESS",
    5: "NOT_FOUND",
    9: "INVALID_MID",
    10: "NOT_A_MEMBER",
    6: "INVALID_LENGTH",
    7: "NOT_AVAILABLE_USER",
    8: "NOT_AUTHORIZED_DEVICE",
    14: "NOT_AUTHORIZED_SESSION",
    11: "INCOMPATIBLE_APP_VERSION",
    12: "NOT_READY",
    13: "NOT_AVAILABLE_SESSION",
    15: "SYSTEM_ERROR",
    16: "NO_AVAILABLE_VERIFICATION_METHOD",
    17: "NOT_AUTHENTICATED",
    18: "INVALID_IDENTITY_CREDENTIAL",
    19: "NOT_AVAILABLE_IDENTITY_IDENTIFIER",
    20: "INTERNAL_ERROR",
    21: "NO_SUCH_IDENTITY_IDENFIER",
    22: "DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY",
    23: "ILLEGAL_IDENTITY_CREDENTIAL",
    24: "UNKNOWN_CHANNEL",
    25: "NO_SUCH_MESSAGE_BOX",
    26: "NOT_AVAILABLE_MESSAGE_BOX",
    27: "CHANNEL_DOES_NOT_MATCH",
    28: "NOT_YOUR_MESSAGE",
    29: "MESSAGE_DEFINED_ERROR",
    30: "USER_CANNOT_ACCEPT_PRESENTS",
    32: "USER_NOT_STICKER_OWNER",
    33: "MAINTENANCE_ERROR",
    34: "ACCOUNT_NOT_MATCHED",
    35: "ABUSE_BLOCK",
    36: "NOT_FRIEND",
    37: "NOT_ALLOWED_CALL",
    38: "BLOCK_FRIEND",
    39: "INCOMPATIBLE_VOIP_VERSION",
    40: "INVALID_SNS_ACCESS_TOKEN",
    41: "EXTERNAL_SERVICE_NOT_AVAILABLE",
    42: "NOT_ALLOWED_ADD_CONTACT",
    43: "NOT_CERTIFICATED",
    44: "NOT_ALLOWED_SECONDARY_DEVICE",
    45: "INVALID_PIN_CODE",
    46: "NOT_FOUND_IDENTITY_CREDENTIAL",
    47: "EXCEED_FILE_MAX_SIZE",
    48: "EXCEED_DAILY_QUOTA",
    49: "NOT_SUPPORT_SEND_FILE",
    50: "MUST_UPGRADE",
    51: "NOT_AVAILABLE_PIN_CODE_SESSION",
    52: "EXPIRED_REVISION",
    54: "NOT_YET_PHONE_NUMBER",
    55: "BAD_CALL_NUMBER",
    56: "UNAVAILABLE_CALL_NUMBER",
    57: "NOT_SUPPORT_CALL_SERVICE",
    58: "CONGESTION_CONTROL",
    59: "NO_BALANCE",
    60: "NOT_PERMITTED_CALLER_ID",
    61: "NO_CALLER_ID_LIMIT_EXCEEDED",
    62: "CALLER_ID_VERIFICATION_REQUIRED",
    63: "NO_CALLER_ID_LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED",
    64: "MESSAGE_NOT_FOUND",
    65: "INVALID_ACCOUNT_MIGRATION_PINCODE_FORMAT",
    66: "ACCOUNT_MIGRATION_PINCODE_NOT_MATCHED",
    67: "ACCOUNT_MIGRATION_PINCODE_BLOCKED",
    69: "INVALID_PASSWORD_FORMAT",
    70: "FEATURE_RESTRICTED",
    71: "MESSAGE_NOT_DESTRUCTIBLE",
    72: "PAID_CALL_REDEEM_FAILED",
    73: "PREVENTED_JOIN_BY_TICKET",
    75: "SEND_MESSAGE_NOT_PERMITTED_FROM_LINE_AT",
    76: "SEND_MESSAGE_NOT_PERMITTED_WHILE_AUTO_REPLY",
    77: "SECURITY_CENTER_NOT_VERIFIED",
    78: "SECURITY_CENTER_BLOCKED_BY_SETTING",
    79: "SECURITY_CENTER_BLOCKED",
    80: "TALK_PROXY_EXCEPTION",
    81: "E2EE_INVALID_PROTOCOL",
    82: "E2EE_RETRY_ENCRYPT",
    83: "E2EE_UPDATE_SENDER_KEY",
    84: "E2EE_UPDATE_RECEIVER_KEY",
    85: "E2EE_INVALID_ARGUMENT",
    86: "E2EE_INVALID_VERSION",
    87: "E2EE_SENDER_DISABLED",
    88: "E2EE_RECEIVER_DISABLED",
    89: "E2EE_SENDER_NOT_ALLOWED",
    90: "E2EE_RECEIVER_NOT_ALLOWED",
    91: "E2EE_RESEND_FAIL",
    92: "E2EE_RESEND_OK",
    93: "HITOKOTO_BACKUP_NO_AVAILABLE_DATA",
    94: "E2EE_UPDATE_PRIMARY_DEVICE",
    95: "SUCCESS",
    96: "CANCEL",
    97: "E2EE_PRIMARY_NOT_SUPPORT",
    98: "E2EE_RETRY_PLAIN",
    99: "E2EE_RECREATE_GROUP_KEY",
    100: "E2EE_GROUP_TOO_MANY_MEMBERS",
    101: "SERVER_BUSY",
    102: "NOT_ALLOWED_ADD_FOLLOW",
    103: "INCOMING_FRIEND_REQUEST_LIMIT",
    104: "OUTGOING_FRIEND_REQUEST_LIMIT",
    105: "OUTGOING_FRIEND_REQUEST_QUOTA",
    106: "DUPLICATED",
    107: "BANNED",
    108: "NOT_AN_INVITEE",
    109: "NOT_AN_OUTSIDER",
    111: "EMPTY_GROUP",
    112: "EXCEED_FOLLOW_LIMIT",
    113: "UNSUPPORTED_ACCOUNT_TYPE",
  }

  _NAMES_TO_VALUES = {
    "ILLEGAL_ARGUMENT": 0,
    "AUTHENTICATION_FAILED": 1,
    "DB_FAILED": 2,
    "INVALID_STATE": 3,
    "EXCESSIVE_ACCESS": 4,
    "NOT_FOUND": 5,
    "INVALID_MID": 9,
    "NOT_A_MEMBER": 10,
    "INVALID_LENGTH": 6,
    "NOT_AVAILABLE_USER": 7,
    "NOT_AUTHORIZED_DEVICE": 8,
    "NOT_AUTHORIZED_SESSION": 14,
    "INCOMPATIBLE_APP_VERSION": 11,
    "NOT_READY": 12,
    "NOT_AVAILABLE_SESSION": 13,
    "SYSTEM_ERROR": 15,
    "NO_AVAILABLE_VERIFICATION_METHOD": 16,
    "NOT_AUTHENTICATED": 17,
    "INVALID_IDENTITY_CREDENTIAL": 18,
    "NOT_AVAILABLE_IDENTITY_IDENTIFIER": 19,
    "INTERNAL_ERROR": 20,
    "NO_SUCH_IDENTITY_IDENFIER": 21,
    "DEACTIVATED_ACCOUNT_BOUND_TO_THIS_IDENTITY": 22,
    "ILLEGAL_IDENTITY_CREDENTIAL": 23,
    "UNKNOWN_CHANNEL": 24,
    "NO_SUCH_MESSAGE_BOX": 25,
    "NOT_AVAILABLE_MESSAGE_BOX": 26,
    "CHANNEL_DOES_NOT_MATCH": 27,
    "NOT_YOUR_MESSAGE": 28,
    "MESSAGE_DEFINED_ERROR": 29,
    "USER_CANNOT_ACCEPT_PRESENTS": 30,
    "USER_NOT_STICKER_OWNER": 32,
    "MAINTENANCE_ERROR": 33,
    "ACCOUNT_NOT_MATCHED": 34,
    "ABUSE_BLOCK": 35,
    "NOT_FRIEND": 36,
    "NOT_ALLOWED_CALL": 37,
    "BLOCK_FRIEND": 38,
    "INCOMPATIBLE_VOIP_VERSION": 39,
    "INVALID_SNS_ACCESS_TOKEN": 40,
    "EXTERNAL_SERVICE_NOT_AVAILABLE": 41,
    "NOT_ALLOWED_ADD_CONTACT": 42,
    "NOT_CERTIFICATED": 43,
    "NOT_ALLOWED_SECONDARY_DEVICE": 44,
    "INVALID_PIN_CODE": 45,
    "NOT_FOUND_IDENTITY_CREDENTIAL": 46,
    "EXCEED_FILE_MAX_SIZE": 47,
    "EXCEED_DAILY_QUOTA": 48,
    "NOT_SUPPORT_SEND_FILE": 49,
    "MUST_UPGRADE": 50,
    "NOT_AVAILABLE_PIN_CODE_SESSION": 51,
    "EXPIRED_REVISION": 52,
    "NOT_YET_PHONE_NUMBER": 54,
    "BAD_CALL_NUMBER": 55,
    "UNAVAILABLE_CALL_NUMBER": 56,
    "NOT_SUPPORT_CALL_SERVICE": 57,
    "CONGESTION_CONTROL": 58,
    "NO_BALANCE": 59,
    "NOT_PERMITTED_CALLER_ID": 60,
    "NO_CALLER_ID_LIMIT_EXCEEDED": 61,
    "CALLER_ID_VERIFICATION_REQUIRED": 62,
    "NO_CALLER_ID_LIMIT_EXCEEDED_AND_VERIFICATION_REQUIRED": 63,
    "MESSAGE_NOT_FOUND": 64,
    "INVALID_ACCOUNT_MIGRATION_PINCODE_FORMAT": 65,
    "ACCOUNT_MIGRATION_PINCODE_NOT_MATCHED": 66,
    "ACCOUNT_MIGRATION_PINCODE_BLOCKED": 67,
    "INVALID_PASSWORD_FORMAT": 69,
    "FEATURE_RESTRICTED": 70,
    "MESSAGE_NOT_DESTRUCTIBLE": 71,
    "PAID_CALL_REDEEM_FAILED": 72,
    "PREVENTED_JOIN_BY_TICKET": 73,
    "SEND_MESSAGE_NOT_PERMITTED_FROM_LINE_AT": 75,
    "SEND_MESSAGE_NOT_PERMITTED_WHILE_AUTO_REPLY": 76,
    "SECURITY_CENTER_NOT_VERIFIED": 77,
    "SECURITY_CENTER_BLOCKED_BY_SETTING": 78,
    "SECURITY_CENTER_BLOCKED": 79,
    "TALK_PROXY_EXCEPTION": 80,
    "E2EE_INVALID_PROTOCOL": 81,
    "E2EE_RETRY_ENCRYPT": 82,
    "E2EE_UPDATE_SENDER_KEY": 83,
    "E2EE_UPDATE_RECEIVER_KEY": 84,
    "E2EE_INVALID_ARGUMENT": 85,
    "E2EE_INVALID_VERSION": 86,
    "E2EE_SENDER_DISABLED": 87,
    "E2EE_RECEIVER_DISABLED": 88,
    "E2EE_SENDER_NOT_ALLOWED": 89,
    "E2EE_RECEIVER_NOT_ALLOWED": 90,
    "E2EE_RESEND_FAIL": 91,
    "E2EE_RESEND_OK": 92,
    "HITOKOTO_BACKUP_NO_AVAILABLE_DATA": 93,
    "E2EE_UPDATE_PRIMARY_DEVICE": 94,
    "SUCCESS": 95,
    "CANCEL": 96,
    "E2EE_PRIMARY_NOT_SUPPORT": 97,
    "E2EE_RETRY_PLAIN": 98,
    "E2EE_RECREATE_GROUP_KEY": 99,
    "E2EE_GROUP_TOO_MANY_MEMBERS": 100,
    "SERVER_BUSY": 101,
    "NOT_ALLOWED_ADD_FOLLOW": 102,
    "INCOMING_FRIEND_REQUEST_LIMIT": 103,
    "OUTGOING_FRIEND_REQUEST_LIMIT": 104,
    "OUTGOING_FRIEND_REQUEST_QUOTA": 105,
    "DUPLICATED": 106,
    "BANNED": 107,
    "NOT_AN_INVITEE": 108,
    "NOT_AN_OUTSIDER": 109,
    "EMPTY_GROUP": 111,
    "EXCEED_FOLLOW_LIMIT": 112,
    "UNSUPPORTED_ACCOUNT_TYPE": 113,
  }

class ResponseType:
  UNKNOWN = 0
  SUCCESS = 1
  REQUIRE_SERVER_SIDE_EMAIL = 2
  REQUIRE_CLIENT_SIDE_EMAIL = 3

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "SUCCESS",
    2: "REQUIRE_SERVER_SIDE_EMAIL",
    3: "REQUIRE_CLIENT_SIDE_EMAIL",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "SUCCESS": 1,
    "REQUIRE_SERVER_SIDE_EMAIL": 2,
    "REQUIRE_CLIENT_SIDE_EMAIL": 3,
  }

class IdentityProvider:
  UNKNOWN = 0
  LINE = 1
  NAVER_KR = 2
  LINE_PHONE = 3

  _VALUES_TO_NAMES = {
    0: "UNKNOWN",
    1: "LINE",
    2: "NAVER_KR",
    3: "LINE_PHONE",
  }

  _NAMES_TO_VALUES = {
    "UNKNOWN": 0,
    "LINE": 1,
    "NAVER_KR": 2,
    "LINE_PHONE": 3,
  }


class TalkException(TException):
  """
  Attributes:
   - code
   - reason
   - parameterMap
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
    (2, TType.STRING, 'reason', None, None, ), # 2
    (3, TType.MAP, 'parameterMap', (TType.STRING,None,TType.STRING,None), None, ), # 3
  )

  def __init__(self, code=None, reason=None, parameterMap=None,):
    self.code = code
    self.reason = reason
    self.parameterMap = parameterMap

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.reason = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.parameterMap = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin()
          for _i4 in xrange(_size0):
            _key5 = iprot.readString();
            _val6 = iprot.readString();
            self.parameterMap[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TalkException')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    if self.reason is not None:
      oprot.writeFieldBegin('reason', TType.STRING, 2)
      oprot.writeString(self.reason)
      oprot.writeFieldEnd()
    if self.parameterMap is not None:
      oprot.writeFieldBegin('parameterMap', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.parameterMap))
      for kiter7,viter8 in self.parameterMap.items():
        oprot.writeString(kiter7)
        oprot.writeString(viter8)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AuthKeyExchangeResponse:
  """
  Attributes:
   - publicKey
   - nonce
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'publicKey', None, None, ), # 1
    (2, TType.STRING, 'nonce', None, None, ), # 2
  )

  def __init__(self, publicKey=None, nonce=None,):
    self.publicKey = publicKey
    self.nonce = nonce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.publicKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.nonce = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AuthKeyExchangeResponse')
    if self.publicKey is not None:
      oprot.writeFieldBegin('publicKey', TType.STRING, 1)
      oprot.writeString(self.publicKey)
      oprot.writeFieldEnd()
    if self.nonce is not None:
      oprot.writeFieldBegin('nonce', TType.STRING, 2)
      oprot.writeString(self.nonce)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AuthLoginRequest:
  """
  Attributes:
   - authLoginVersion
   - metaData
   - chipherText
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'authLoginVersion', None, None, ), # 1
    (2, TType.MAP, 'metaData', (TType.STRING,None,TType.STRING,None), None, ), # 2
    (3, TType.STRING, 'chipherText', None, None, ), # 3
  )

  def __init__(self, authLoginVersion=None, metaData=None, chipherText=None,):
    self.authLoginVersion = authLoginVersion
    self.metaData = metaData
    self.chipherText = chipherText

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.authLoginVersion = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.metaData = {}
          (_ktype10, _vtype11, _size9 ) = iprot.readMapBegin()
          for _i13 in xrange(_size9):
            _key14 = iprot.readString();
            _val15 = iprot.readString();
            self.metaData[_key14] = _val15
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.chipherText = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AuthLoginRequest')
    if self.authLoginVersion is not None:
      oprot.writeFieldBegin('authLoginVersion', TType.I32, 1)
      oprot.writeI32(self.authLoginVersion)
      oprot.writeFieldEnd()
    if self.metaData is not None:
      oprot.writeFieldBegin('metaData', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metaData))
      for kiter16,viter17 in self.metaData.items():
        oprot.writeString(kiter16)
        oprot.writeString(viter17)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.chipherText is not None:
      oprot.writeFieldBegin('chipherText', TType.STRING, 3)
      oprot.writeString(self.chipherText)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AuthLoginResponse:
  """
  Attributes:
   - metaData
   - chipherText
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'metaData', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.STRING, 'chipherText', None, None, ), # 2
  )

  def __init__(self, metaData=None, chipherText=None,):
    self.metaData = metaData
    self.chipherText = chipherText

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.metaData = {}
          (_ktype19, _vtype20, _size18 ) = iprot.readMapBegin()
          for _i22 in xrange(_size18):
            _key23 = iprot.readString();
            _val24 = iprot.readString();
            self.metaData[_key23] = _val24
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.chipherText = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AuthLoginResponse')
    if self.metaData is not None:
      oprot.writeFieldBegin('metaData', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metaData))
      for kiter25,viter26 in self.metaData.items():
        oprot.writeString(kiter25)
        oprot.writeString(viter26)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.chipherText is not None:
      oprot.writeFieldBegin('chipherText', TType.STRING, 2)
      oprot.writeString(self.chipherText)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IdentifierConfirmationRequest:
  """
  Attributes:
   - metaData
   - forceRegistration
   - verificationCode
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'metaData', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.BOOL, 'forceRegistration', None, None, ), # 2
    (3, TType.STRING, 'verificationCode', None, None, ), # 3
  )

  def __init__(self, metaData=None, forceRegistration=None, verificationCode=None,):
    self.metaData = metaData
    self.forceRegistration = forceRegistration
    self.verificationCode = verificationCode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.metaData = {}
          (_ktype28, _vtype29, _size27 ) = iprot.readMapBegin()
          for _i31 in xrange(_size27):
            _key32 = iprot.readString();
            _val33 = iprot.readString();
            self.metaData[_key32] = _val33
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.forceRegistration = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.verificationCode = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IdentifierConfirmationRequest')
    if self.metaData is not None:
      oprot.writeFieldBegin('metaData', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metaData))
      for kiter34,viter35 in self.metaData.items():
        oprot.writeString(kiter34)
        oprot.writeString(viter35)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.forceRegistration is not None:
      oprot.writeFieldBegin('forceRegistration', TType.BOOL, 2)
      oprot.writeBool(self.forceRegistration)
      oprot.writeFieldEnd()
    if self.verificationCode is not None:
      oprot.writeFieldBegin('verificationCode', TType.STRING, 3)
      oprot.writeString(self.verificationCode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IdentityCredentialRequest:
  """
  Attributes:
   - metaData
   - identityProvider
   - chipherKeyId
   - chipherText
   - confirmationRequest
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'metaData', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.I32, 'identityProvider', None, None, ), # 2
    (3, TType.STRING, 'chipherKeyId', None, None, ), # 3
    (4, TType.STRING, 'chipherText', None, None, ), # 4
    (5, TType.STRUCT, 'confirmationRequest', (IdentifierConfirmationRequest, IdentifierConfirmationRequest.thrift_spec), None, ), # 5
  )

  def __init__(self, metaData=None, identityProvider=None, chipherKeyId=None, chipherText=None, confirmationRequest=None,):
    self.metaData = metaData
    self.identityProvider = identityProvider
    self.chipherKeyId = chipherKeyId
    self.chipherText = chipherText
    self.confirmationRequest = confirmationRequest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.metaData = {}
          (_ktype37, _vtype38, _size36 ) = iprot.readMapBegin()
          for _i40 in xrange(_size36):
            _key41 = iprot.readString();
            _val42 = iprot.readString();
            self.metaData[_key41] = _val42
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.identityProvider = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.chipherKeyId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.chipherText = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.confirmationRequest = IdentifierConfirmationRequest()
          self.confirmationRequest.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IdentityCredentialRequest')
    if self.metaData is not None:
      oprot.writeFieldBegin('metaData', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metaData))
      for kiter43,viter44 in self.metaData.items():
        oprot.writeString(kiter43)
        oprot.writeString(viter44)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.identityProvider is not None:
      oprot.writeFieldBegin('identityProvider', TType.I32, 2)
      oprot.writeI32(self.identityProvider)
      oprot.writeFieldEnd()
    if self.chipherKeyId is not None:
      oprot.writeFieldBegin('chipherKeyId', TType.STRING, 3)
      oprot.writeString(self.chipherKeyId)
      oprot.writeFieldEnd()
    if self.chipherText is not None:
      oprot.writeFieldBegin('chipherText', TType.STRING, 4)
      oprot.writeString(self.chipherText)
      oprot.writeFieldEnd()
    if self.confirmationRequest is not None:
      oprot.writeFieldBegin('confirmationRequest', TType.STRUCT, 5)
      self.confirmationRequest.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IdentityCredentialResponse:
  """
  Attributes:
   - metaData
   - responseType
   - confirmationVerifier
   - timeoutInSecond
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'metaData', (TType.STRING,None,TType.STRING,None), None, ), # 1
    (2, TType.I32, 'responseType', None, None, ), # 2
    (3, TType.STRING, 'confirmationVerifier', None, None, ), # 3
    (4, TType.I64, 'timeoutInSecond', None, None, ), # 4
  )

  def __init__(self, metaData=None, responseType=None, confirmationVerifier=None, timeoutInSecond=None,):
    self.metaData = metaData
    self.responseType = responseType
    self.confirmationVerifier = confirmationVerifier
    self.timeoutInSecond = timeoutInSecond

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.metaData = {}
          (_ktype46, _vtype47, _size45 ) = iprot.readMapBegin()
          for _i49 in xrange(_size45):
            _key50 = iprot.readString();
            _val51 = iprot.readString();
            self.metaData[_key50] = _val51
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.responseType = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.confirmationVerifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timeoutInSecond = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IdentityCredentialResponse')
    if self.metaData is not None:
      oprot.writeFieldBegin('metaData', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metaData))
      for kiter52,viter53 in self.metaData.items():
        oprot.writeString(kiter52)
        oprot.writeString(viter53)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.responseType is not None:
      oprot.writeFieldBegin('responseType', TType.I32, 2)
      oprot.writeI32(self.responseType)
      oprot.writeFieldEnd()
    if self.confirmationVerifier is not None:
      oprot.writeFieldBegin('confirmationVerifier', TType.STRING, 3)
      oprot.writeString(self.confirmationVerifier)
      oprot.writeFieldEnd()
    if self.timeoutInSecond is not None:
      oprot.writeFieldBegin('timeoutInSecond', TType.I64, 4)
      oprot.writeI64(self.timeoutInSecond)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AuthSessionRequest:
  """
  Attributes:
   - metaData
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'metaData', (TType.STRING,None,TType.STRING,None), None, ), # 1
  )

  def __init__(self, metaData=None,):
    self.metaData = metaData

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.metaData = {}
          (_ktype55, _vtype56, _size54 ) = iprot.readMapBegin()
          for _i58 in xrange(_size54):
            _key59 = iprot.readString();
            _val60 = iprot.readString();
            self.metaData[_key59] = _val60
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AuthSessionRequest')
    if self.metaData is not None:
      oprot.writeFieldBegin('metaData', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metaData))
      for kiter61,viter62 in self.metaData.items():
        oprot.writeString(kiter61)
        oprot.writeString(viter62)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class AuthKeyExchangeRequest:
  """
  Attributes:
   - authKeyVersion
   - publicKey
   - nonce
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'authKeyVersion', None, None, ), # 1
    (2, TType.STRING, 'publicKey', None, None, ), # 2
    (3, TType.STRING, 'nonce', None, None, ), # 3
  )

  def __init__(self, authKeyVersion=None, publicKey=None, nonce=None,):
    self.authKeyVersion = authKeyVersion
    self.publicKey = publicKey
    self.nonce = nonce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.authKeyVersion = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.publicKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.nonce = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('AuthKeyExchangeRequest')
    if self.authKeyVersion is not None:
      oprot.writeFieldBegin('authKeyVersion', TType.I32, 1)
      oprot.writeI32(self.authKeyVersion)
      oprot.writeFieldEnd()
    if self.publicKey is not None:
      oprot.writeFieldBegin('publicKey', TType.STRING, 2)
      oprot.writeString(self.publicKey)
      oprot.writeFieldEnd()
    if self.nonce is not None:
      oprot.writeFieldBegin('nonce', TType.STRING, 3)
      oprot.writeString(self.nonce)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UpdatePassword:
  """
  Attributes:
   - authSessionId
   - request
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'authSessionId', None, None, ), # 2
    (3, TType.STRUCT, 'request', (IdentityCredentialRequest, IdentityCredentialRequest.thrift_spec), None, ), # 3
  )

  def __init__(self, authSessionId=None, request=None,):
    self.authSessionId = authSessionId
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.authSessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.request = IdentityCredentialRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UpdatePassword')
    if self.authSessionId is not None:
      oprot.writeFieldBegin('authSessionId', TType.STRING, 2)
      oprot.writeString(self.authSessionId)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 3)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SecurityCenterResult:
  """
  Attributes:
   - uri
   - token
   - cookiePath
   - skip
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'uri', None, None, ), # 1
    (2, TType.STRING, 'token', None, None, ), # 2
    (3, TType.STRING, 'cookiePath', None, None, ), # 3
    (4, TType.BOOL, 'skip', None, None, ), # 4
  )

  def __init__(self, uri=None, token=None, cookiePath=None, skip=None,):
    self.uri = uri
    self.token = token
    self.cookiePath = cookiePath
    self.skip = skip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.uri = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.cookiePath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.skip = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SecurityCenterResult')
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRING, 1)
      oprot.writeString(self.uri)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 2)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.cookiePath is not None:
      oprot.writeFieldBegin('cookiePath', TType.STRING, 3)
      oprot.writeString(self.cookiePath)
      oprot.writeFieldEnd()
    if self.skip is not None:
      oprot.writeFieldBegin('skip', TType.BOOL, 4)
      oprot.writeBool(self.skip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RSAKey:
  """
  Attributes:
   - keynm
   - nvalue
   - evalue
   - sessionKey
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'keynm', None, None, ), # 1
    (2, TType.STRING, 'nvalue', None, None, ), # 2
    (3, TType.STRING, 'evalue', None, None, ), # 3
    (4, TType.STRING, 'sessionKey', None, None, ), # 4
  )

  def __init__(self, keynm=None, nvalue=None, evalue=None, sessionKey=None,):
    self.keynm = keynm
    self.nvalue = nvalue
    self.evalue = evalue
    self.sessionKey = sessionKey

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.keynm = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.nvalue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.evalue = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.sessionKey = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RSAKey')
    if self.keynm is not None:
      oprot.writeFieldBegin('keynm', TType.STRING, 1)
      oprot.writeString(self.keynm)
      oprot.writeFieldEnd()
    if self.nvalue is not None:
      oprot.writeFieldBegin('nvalue', TType.STRING, 2)
      oprot.writeString(self.nvalue)
      oprot.writeFieldEnd()
    if self.evalue is not None:
      oprot.writeFieldBegin('evalue', TType.STRING, 3)
      oprot.writeString(self.evalue)
      oprot.writeFieldEnd()
    if self.sessionKey is not None:
      oprot.writeFieldBegin('sessionKey', TType.STRING, 4)
      oprot.writeString(self.sessionKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class E2EEPublicKey:
  """
  Attributes:
   - version
   - keyId
   - keyData
   - createdTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.I32, 'keyId', None, None, ), # 2
    None, # 3
    (4, TType.STRING, 'keyData', None, None, ), # 4
    (5, TType.BOOL, 'createdTime', None, None, ), # 5
  )

  def __init__(self, version=None, keyId=None, keyData=None, createdTime=None,):
    self.version = version
    self.keyId = keyId
    self.keyData = keyData
    self.createdTime = createdTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.keyId = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.keyData = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.createdTime = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('E2EEPublicKey')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.keyId is not None:
      oprot.writeFieldBegin('keyId', TType.I32, 2)
      oprot.writeI32(self.keyId)
      oprot.writeFieldEnd()
    if self.keyData is not None:
      oprot.writeFieldBegin('keyData', TType.STRING, 4)
      oprot.writeString(self.keyData)
      oprot.writeFieldEnd()
    if self.createdTime is not None:
      oprot.writeFieldBegin('createdTime', TType.BOOL, 5)
      oprot.writeBool(self.createdTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ConfirmIdentifier:
  """
  Attributes:
   - authSessionId
   - request
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'authSessionId', None, None, ), # 2
    (3, TType.STRUCT, 'request', (IdentityCredentialRequest, IdentityCredentialRequest.thrift_spec), None, ), # 3
  )

  def __init__(self, authSessionId=None, request=None,):
    self.authSessionId = authSessionId
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.authSessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.request = IdentityCredentialRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ConfirmIdentifier')
    if self.authSessionId is not None:
      oprot.writeFieldBegin('authSessionId', TType.STRING, 2)
      oprot.writeString(self.authSessionId)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 3)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RemoveIdentifier:
  """
  Attributes:
   - authSessionId
   - request
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'authSessionId', None, None, ), # 2
    (3, TType.STRUCT, 'request', (IdentityCredentialRequest, IdentityCredentialRequest.thrift_spec), None, ), # 3
  )

  def __init__(self, authSessionId=None, request=None,):
    self.authSessionId = authSessionId
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.authSessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.request = IdentityCredentialRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RemoveIdentifier')
    if self.authSessionId is not None:
      oprot.writeFieldBegin('authSessionId', TType.STRING, 2)
      oprot.writeString(self.authSessionId)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 3)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ExchangeKey:
  """
  Attributes:
   - authSessionId
   - request
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'authSessionId', None, None, ), # 2
    (3, TType.STRUCT, 'request', (IdentityCredentialRequest, IdentityCredentialRequest.thrift_spec), None, ), # 3
  )

  def __init__(self, authSessionId=None, request=None,):
    self.authSessionId = authSessionId
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.authSessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.request = IdentityCredentialRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ExchangeKey')
    if self.authSessionId is not None:
      oprot.writeFieldBegin('authSessionId', TType.STRING, 2)
      oprot.writeString(self.authSessionId)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 3)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class GetAuthRSAKey:
  """
  Attributes:
   - authSessionId
   - identityProvider
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'authSessionId', None, None, ), # 2
    (3, TType.I32, 'identityProvider', None, None, ), # 3
  )

  def __init__(self, authSessionId=None, identityProvider=None,):
    self.authSessionId = authSessionId
    self.identityProvider = identityProvider

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.authSessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.identityProvider = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('GetAuthRSAKey')
    if self.authSessionId is not None:
      oprot.writeFieldBegin('authSessionId', TType.STRING, 2)
      oprot.writeString(self.authSessionId)
      oprot.writeFieldEnd()
    if self.identityProvider is not None:
      oprot.writeFieldBegin('identityProvider', TType.I32, 3)
      oprot.writeI32(self.identityProvider)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class RespondE2EELoginRequest:
  """
  Attributes:
   - verifier
   - publicKey
   - encryptedKeyChain
   - hashKeyChain
   - errorCode
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'verifier', None, None, ), # 1
    (2, TType.STRUCT, 'publicKey', (E2EEPublicKey, E2EEPublicKey.thrift_spec), None, ), # 2
    (3, TType.STRING, 'encryptedKeyChain', None, None, ), # 3
    (4, TType.STRING, 'hashKeyChain', None, None, ), # 4
    (5, TType.I32, 'errorCode', None, None, ), # 5
  )

  def __init__(self, verifier=None, publicKey=None, encryptedKeyChain=None, hashKeyChain=None, errorCode=None,):
    self.verifier = verifier
    self.publicKey = publicKey
    self.encryptedKeyChain = encryptedKeyChain
    self.hashKeyChain = hashKeyChain
    self.errorCode = errorCode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.verifier = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.publicKey = E2EEPublicKey()
          self.publicKey.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.encryptedKeyChain = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.hashKeyChain = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.errorCode = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('RespondE2EELoginRequest')
    if self.verifier is not None:
      oprot.writeFieldBegin('verifier', TType.STRING, 1)
      oprot.writeString(self.verifier)
      oprot.writeFieldEnd()
    if self.publicKey is not None:
      oprot.writeFieldBegin('publicKey', TType.STRUCT, 2)
      self.publicKey.write(oprot)
      oprot.writeFieldEnd()
    if self.encryptedKeyChain is not None:
      oprot.writeFieldBegin('encryptedKeyChain', TType.STRING, 3)
      oprot.writeString(self.encryptedKeyChain)
      oprot.writeFieldEnd()
    if self.hashKeyChain is not None:
      oprot.writeFieldBegin('hashKeyChain', TType.STRING, 4)
      oprot.writeString(self.hashKeyChain)
      oprot.writeFieldEnd()
    if self.errorCode is not None:
      oprot.writeFieldBegin('errorCode', TType.I32, 5)
      oprot.writeI32(self.errorCode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IssueTokenForAccountMigrationSettings:
  """
  Attributes:
   - enforce
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.BOOL, 'enforce', None, None, ), # 2
  )

  def __init__(self, enforce=None,):
    self.enforce = enforce

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.BOOL:
          self.enforce = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IssueTokenForAccountMigrationSettings')
    if self.enforce is not None:
      oprot.writeFieldBegin('enforce', TType.BOOL, 2)
      oprot.writeBool(self.enforce)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetClovaCredential:
  """
  Attributes:
   - authSessionId
   - request
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'authSessionId', None, None, ), # 2
    (3, TType.STRUCT, 'request', (IdentityCredentialRequest, IdentityCredentialRequest.thrift_spec), None, ), # 3
  )

  def __init__(self, authSessionId=None, request=None,):
    self.authSessionId = authSessionId
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.authSessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.request = IdentityCredentialRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetClovaCredential')
    if self.authSessionId is not None:
      oprot.writeFieldBegin('authSessionId', TType.STRING, 2)
      oprot.writeString(self.authSessionId)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 3)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class IssueTokenForAccountMigration:
  """
  Attributes:
   - migrationSessionId
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'migrationSessionId', None, None, ), # 2
  )

  def __init__(self, migrationSessionId=None,):
    self.migrationSessionId = migrationSessionId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.migrationSessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IssueTokenForAccountMigration')
    if self.migrationSessionId is not None:
      oprot.writeFieldBegin('migrationSessionId', TType.STRING, 2)
      oprot.writeString(self.migrationSessionId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetIdentifierAndPassword:
  """
  Attributes:
   - authSessionId
   - request
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'authSessionId', None, None, ), # 2
    (3, TType.STRUCT, 'request', (IdentityCredentialRequest, IdentityCredentialRequest.thrift_spec), None, ), # 3
  )

  def __init__(self, authSessionId=None, request=None,):
    self.authSessionId = authSessionId
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.authSessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.request = IdentityCredentialRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetIdentifierAndPassword')
    if self.authSessionId is not None:
      oprot.writeFieldBegin('authSessionId', TType.STRING, 2)
      oprot.writeString(self.authSessionId)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 3)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetIdentifier:
  """
  Attributes:
   - authSessionId
   - request
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'authSessionId', None, None, ), # 2
    (3, TType.STRUCT, 'request', (IdentityCredentialRequest, IdentityCredentialRequest.thrift_spec), None, ), # 3
  )

  def __init__(self, authSessionId=None, request=None,):
    self.authSessionId = authSessionId
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.authSessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.request = IdentityCredentialRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetIdentifier')
    if self.authSessionId is not None:
      oprot.writeFieldBegin('authSessionId', TType.STRING, 2)
      oprot.writeString(self.authSessionId)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 3)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class SetPassword:
  """
  Attributes:
   - authSessionId
   - request
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'authSessionId', None, None, ), # 2
    (3, TType.STRUCT, 'request', (IdentityCredentialRequest, IdentityCredentialRequest.thrift_spec), None, ), # 3
  )

  def __init__(self, authSessionId=None, request=None,):
    self.authSessionId = authSessionId
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.authSessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.request = IdentityCredentialRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('SetPassword')
    if self.authSessionId is not None:
      oprot.writeFieldBegin('authSessionId', TType.STRING, 2)
      oprot.writeString(self.authSessionId)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 3)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UpdateIdentifier:
  """
  Attributes:
   - authSessionId
   - request
  """

  thrift_spec = (
    None, # 0
    None, # 1
    (2, TType.STRING, 'authSessionId', None, None, ), # 2
    (3, TType.STRUCT, 'request', (IdentityCredentialRequest, IdentityCredentialRequest.thrift_spec), None, ), # 3
  )

  def __init__(self, authSessionId=None, request=None,):
    self.authSessionId = authSessionId
    self.request = request

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.STRING:
          self.authSessionId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.request = IdentityCredentialRequest()
          self.request.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UpdateIdentifier')
    if self.authSessionId is not None:
      oprot.writeFieldBegin('authSessionId', TType.STRING, 2)
      oprot.writeString(self.authSessionId)
      oprot.writeFieldEnd()
    if self.request is not None:
      oprot.writeFieldBegin('request', TType.STRUCT, 3)
      self.request.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
